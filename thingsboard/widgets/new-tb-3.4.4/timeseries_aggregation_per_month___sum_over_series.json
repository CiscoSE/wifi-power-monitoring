{
  "alias": "timeseries_aggregation_per_month_sum_over_series",
  "name": "Timeseries aggregation per month & sum over series",
  "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
  "description": "Displays aggregation (sum) of set of timeseries in buckets of months. For example, monthly energy consumption.",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 8,
    "sizeY": 5,
    "resources": [],
    "templateHtml": "",
    "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
    "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, 'bar');\n    self.ctx.widgetTitle = self.ctx.data[0].datasource.aliasName + \" \" + self.ctx.widgetConfig.title;\n    self.ctx.updateWidgetParams();\n}\n\nself.getBeginningofMonth = function(timestamp) {\n    var date = new Date(timestamp);\n    var year = date.getFullYear();\n    var month = date.getMonth();\n\n    return new Date(year, month, 1).getTime();\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getMonthNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getMonth();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\nself.popMinimalWIP = function() {\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n}\n\nself.computeSums = function() {\n    let prevTimeOfTheMonth = null;\n    let sums = {};\n    let months = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Sum aggregation per month\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        // Deep copy\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp, stopHourTimestamp;\n\n        for (let j = 0; j < timeseries.length; j++) {\n\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(\n                    timeseries[0][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    hourUnixTs; // 1h later\n            }\n\n            month = self.getMonthNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n\n\n            const timeOfTheMonth = Math.round(\n                self.getBeginningofMonth(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheMonth\n            if (prevTimeOfTheMonth == null) {\n                prevTimeOfTheMonth = timeOfTheMonth;\n            }\n\n            if ((prevTimeOfTheMonth in months) == false) {\n                months[prevTimeOfTheMonth] = \"\";\n                sums[prevTimeOfTheMonth] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][\n                    0\n                ] && timeseries[j][0] <\n                stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints++;\n            } else {\n                if (j + 1 < timeseries.length) {\n                    // We exceeded that time window. Move on to the next one.\n                    startHourTimestamp = Math.floor(\n                        timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                    stopHourTimestamp =\n                        startHourTimestamp +\n                        hourUnixTs; // 1h later\n                }\n\n                // Sum up values\n                sums[prevTimeOfTheMonth] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheMonth] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n\n            if (timeOfTheMonth != prevTimeOfTheMonth) {\n                prevTimeOfTheMonth = timeOfTheMonth;\n            }\n        }\n    }\n    \n    // Create array Array\n    let j = 0;\n    for (const [key, value] of Object.entries(\n            months)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n    \n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }    \n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
    "settingsSchema": "{}",
    "dataKeySettingsSchema": "{}",
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Timeseries aggregation per month & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
  }
}