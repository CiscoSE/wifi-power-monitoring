{
  "widgetsBundle": {
    "alias": "test2",
    "title": "Custom made",
    "image": "data:image/png;base64,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",
    "description": null,
    "externalId": null,
    "name": "Custom made"
  },
  "widgetTypes": [
    {
      "alias": "average",
      "name": "Average",
      "image": null,
      "description": null,
      "descriptor": {
        "type": "latest",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "",
        "templateCss": "#container {\n    overflow: auto;\n}\n\n.tbDatasource-container {\n    margin: 5px;\n    padding: 8px;\n}\n\n.tbDatasource-title {\n    font-size: 1.200rem;\n    font-weight: 500;\n    padding-bottom: 10px;\n}\n\n.tbDatasource-table {\n    width: 100%;\n    box-shadow: 0 0 10px #ccc;\n    border-collapse: collapse;\n    white-space: nowrap;\n    font-size: 1.000rem;\n    color: #757575;\n}\n\n.tbDatasource-table td {\n    position: relative;\n    border-top: 1px solid rgba(0, 0, 0, 0.12);\n    border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n    padding: 0px 18px;\n    box-sizing: border-box;\n}",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\nself.onInit = function() {\n\n    self.ctx.datasourceTitleCells = [];\n    self.ctx.valueCells = [];\n    self.ctx.labelCells = [];\n\n    // Create table with 1 entry\n    self.ctx.$container.append(\n        \"<div id='singleentry' class='tbDatasource-container'></div>\"\n    );\n    var datasourceContainer = $('#singleentry',\n        self.ctx.$container);\n\n    datasourceContainer.append(\n        \"<div class='tbDatasource-title'>Average</div>\"\n    );\n\n    var datasourceTitleCell = $('.tbDatasource-title',\n        datasourceContainer);\n    self.ctx.datasourceTitleCells.push(\n        datasourceTitleCell);\n\n    datasourceContainer.append(\n        \"<table id='table0' class='tbDatasource-table'><col width='30%'><col width='70%'></table>\"\n    );\n\n    // Each datasource is a device, for example\n    for (var i = 0; i < self.ctx.datasources\n        .length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n\n        var tableId = 'table' + i;\n        var table = $('#' + tableId, self.ctx\n            .$container);\n\n        // Gets value of key for the first device - why??\n        for (var a = 0; a < tbDatasource.dataKeys\n            .length; a++) {\n            var dataKey = tbDatasource.dataKeys[a];\n            var labelCellId = 'labelCell' + a;\n            var cellId = 'cell' + a;\n            table.append(\"<tr><td id='\" + labelCellId +\n                \"'>\" + dataKey.label +\n                \"</td><td id='\" + cellId +\n                \"'></td></tr>\");\n            var labelCell = $('#' + labelCellId, table);\n            self.ctx.labelCells.push(labelCell);\n            var valueCell = $('#' + cellId, table);\n            self.ctx.valueCells.push(valueCell);\n        }\n\n    }\n\n    self.onResize();\n}\n\n// Compute sum over datasources (e.g. entities such as device1, device2, device3)\nself.onDataUpdated = function() {\n    var sum = 0;\n    // For each entity (device1, device2, etc)\n    for (var i = 0; i < self.ctx.datasources\n        .length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n        for (var a = 0; a < tbDatasource.dataKeys\n            .length; a++) {\n            // Read all values\n            var cellData = self.ctx.data[i];\n            if (cellData && cellData.data && cellData\n                .data.length > 0) {\n                var tvPair = cellData.data[cellData.data\n                    .length -\n                    1];\n                var value = tvPair[1];\n                var textValue;\n                //toDo -> + IsNumber\n\n                if (isNumber(value)) {\n                    var decimals = self.ctx.decimals;\n                    var units = self.ctx.units;\n                    if (cellData.dataKey.decimals ||\n                        cellData.dataKey.decimals === 0\n                        ) {\n                        decimals = cellData.dataKey\n                            .decimals;\n                    }\n                    if (cellData.dataKey.units) {\n                        units = cellData.dataKey.units;\n                    }\n                    txtValue = self.ctx.utils\n                        .formatValue(value, decimals,\n                            units, true);\n                    sum = sum + parseFloat(value, 2);\n                } else {\n                    txtValue = value;\n                }\n            }\n        }\n    }\n\n    if (self.ctx.datasources.length > 0) {\n        avg = sum / self.ctx.datasources.length;\n    }\n    //self.ctx.valueCells[0].html(avg.toFixed(2));\n    measurement = avg.toFixed(2) + \" \" + self.ctx.units;\n    self.ctx.valueCells[0].html(measurement);\n\n    function isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n}\n\nself.onResize = function() {\n    var datasourceTitleFontSize = self.ctx.height / 8;\n    if (self.ctx.width / self.ctx.height <= 1.5) {\n        datasourceTitleFontSize = self.ctx.width / 12;\n    }\n    datasourceTitleFontSize = Math.min(\n        datasourceTitleFontSize, 20);\n    for (var i = 0; i < self.ctx.datasourceTitleCells\n        .length; i++) {\n        self.ctx.datasourceTitleCells[i].css(\n            'font-size', datasourceTitleFontSize +\n            'px');\n    }\n    var valueFontSize = self.ctx.height / 9;\n    var labelFontSize = self.ctx.height / 9;\n    if (self.ctx.width / self.ctx.height <= 1.5) {\n        valueFontSize = self.ctx.width / 15;\n        labelFontSize = self.ctx.width / 15;\n    }\n    valueFontSize = Math.min(valueFontSize, 18);\n    labelFontSize = Math.min(labelFontSize, 18);\n\n    for (i = 0; i < self.ctx.valueCells; i++) {\n        self.ctx.valueCells[i].css('font-size',\n            valueFontSize + 'px');\n        self.ctx.valueCells[i].css('height',\n            valueFontSize * 2.5 + 'px');\n        self.ctx.valueCells[i].css('padding', '0px ' +\n            valueFontSize + 'px');\n        self.ctx.labelCells[i].css('font-size',\n            labelFontSize + 'px');\n        self.ctx.labelCells[i].css('height',\n            labelFontSize * 2.5 + 'px');\n        self.ctx.labelCells[i].css('padding', '0px ' +\n            labelFontSize + 'px');\n    }\n}\n\nself.onDestroy = function() {}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Average\"}"
      }
    },
    {
      "alias": "test2",
      "name": "Sum all",
      "image": null,
      "description": null,
      "descriptor": {
        "type": "latest",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "",
        "templateCss": "#container {\n    overflow: auto;\n}\n\n.tbDatasource-container {\n    margin: 5px;\n    padding: 8px;\n}\n\n.tbDatasource-title {\n    font-size: 1.200rem;\n    font-weight: 500;\n    padding-bottom: 10px;\n}\n\n.tbDatasource-table {\n    width: 100%;\n    box-shadow: 0 0 10px #ccc;\n    border-collapse: collapse;\n    white-space: nowrap;\n    font-size: 1.000rem;\n    color: #757575;\n}\n\n.tbDatasource-table td {\n    position: relative;\n    border-top: 1px solid rgba(0, 0, 0, 0.12);\n    border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n    padding: 0px 18px;\n    box-sizing: border-box;\n}",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\nself.onInit = function() {\n    \n    self.ctx.datasourceTitleCells = [];\n    self.ctx.valueCells = [];\n    self.ctx.labelCells = [];\n\n    // Create table with 1 entry\n    self.ctx.$container.append(\n    \"<div id='singleentry' class='tbDatasource-container'></div>\"\n    );\n    var datasourceContainer = $('#singleentry',\n    self.ctx.$container);\n\n    datasourceContainer.append(\n        \"<div class='tbDatasource-title'>Sum</div>\"\n    );\n\n    var datasourceTitleCell = $('.tbDatasource-title', datasourceContainer);\n    self.ctx.datasourceTitleCells.push(datasourceTitleCell);\n    \n    datasourceContainer.append(\n        \"<table id='table0' class='tbDatasource-table'><col width='30%'><col width='70%'></table>\"\n    );\n\n    // Each datasource is a device, for example\n    for (var i=0; i < self.ctx.datasources.length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n        \n        var tableId = 'table' + i;\n        var table = $('#' + tableId, self.ctx.$container);\n\n        // Gets value of key for the first device - why??\n        for (var a = 0; a < tbDatasource.dataKeys.length; a++) {\n            var dataKey = tbDatasource.dataKeys[a];\n            var labelCellId = 'labelCell' + a;\n            var cellId = 'cell' + a;\n            table.append(\"<tr><td id='\" + labelCellId + \"'>\" + dataKey.label +\n                \"</td><td id='\" + cellId +\n                \"'></td></tr>\");\n            var labelCell = $('#' + labelCellId, table);\n            self.ctx.labelCells.push(labelCell);\n            var valueCell = $('#' + cellId, table);\n            self.ctx.valueCells.push(valueCell);\n        }\n        \n    }    \n    \n    self.onResize();\n}\n\n// Compute sum over datasources (e.g. entities such as device1, device2, device3)\nself.onDataUpdated = function() {\n    var sum = 0;\n    // For each entity (device1, device2, etc)\n    for (var i=0; i < self.ctx.datasources.length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n        for (var a = 0; a < tbDatasource.dataKeys.length; a++) {\n            // Read all values\n            var cellData = self.ctx.data[i];\n            if (cellData && cellData.data && cellData.data.length > 0) {\n                var tvPair = cellData.data[cellData.data.length -\n                    1];\n                var value = tvPair[1];\n                var textValue;\n                //toDo -> + IsNumber\n                \n                if (isNumber(value)) {\n                    var decimals = self.ctx.decimals;\n                    var units = self.ctx.units;\n                    if (cellData.dataKey.decimals || cellData.dataKey.decimals === 0) {\n                        decimals = cellData.dataKey.decimals;\n                    }\n                    if (cellData.dataKey.units) {\n                        units = cellData.dataKey.units;\n                    }\n                    txtValue = self.ctx.utils.formatValue(value, decimals, units, true);\n                    sum = sum + parseFloat(value);\n                } else {\n                    txtValue = value;\n                }\n            }\n        }\n    }\n    \n    measurement = sum.toFixed(2) + \" \" + self.ctx.units; // Keep only 2 digits after decimal\n    self.ctx.valueCells[0].html(measurement);\n    \n    function isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n}\n\nself.onResize = function() {\n    var datasourceTitleFontSize = self.ctx.height/8;\n    if (self.ctx.width/self.ctx.height <= 1.5) {\n        datasourceTitleFontSize = self.ctx.width/12;\n    }\n    datasourceTitleFontSize = Math.min(datasourceTitleFontSize, 20);\n    for (var i = 0; i < self.ctx.datasourceTitleCells.length; i++) {\n        self.ctx.datasourceTitleCells[i].css('font-size', datasourceTitleFontSize+'px');\n    }\n    var valueFontSize = self.ctx.height/9;\n    var labelFontSize = self.ctx.height/9;\n    if (self.ctx.width/self.ctx.height <= 1.5) {\n        valueFontSize = self.ctx.width/15;\n        labelFontSize = self.ctx.width/15;\n    }\n    valueFontSize = Math.min(valueFontSize, 18);\n    labelFontSize = Math.min(labelFontSize, 18);\n\n    for (i = 0; i < self.ctx.valueCells; i++) {\n        self.ctx.valueCells[i].css('font-size', valueFontSize+'px');\n        self.ctx.valueCells[i].css('height', valueFontSize*2.5+'px');\n        self.ctx.valueCells[i].css('padding', '0px ' + valueFontSize + 'px');\n        self.ctx.labelCells[i].css('font-size', labelFontSize+'px');\n        self.ctx.labelCells[i].css('height', labelFontSize*2.5+'px');\n        self.ctx.labelCells[i].css('padding', '0px ' + labelFontSize + 'px');\n    }    \n}\n\nself.onDestroy = function() {\n}\n",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Sum all\"}"
      }
    },
    {
      "alias": "polar_area_chart_js",
      "name": "Sums over entities grouped by Alias",
      "image": "data:image/png;base64,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",
      "description": "Displays sum of latest values of the attributes or timeseries data for multiple entities in a polar area chart. Supports numeric values only.",
      "descriptor": {
        "type": "latest",
        "sizeX": 7,
        "sizeY": 5,
        "resources": [
          {
            "url": "https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.3.0/Chart.min.js"
          }
        ],
        "templateHtml": "<canvas id=\"pieChart\"></canvas>\n",
        "templateCss": "",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\nvar pieData = {\n    labels: [],\n    datasets: []\n};\n\nvar aliases = {};\n\nself.onInit = function() {\n    $scope = self.ctx.$scope;\n    utils = $scope.$injector.get(self.ctx.servicesMap\n        .get('utils'));\n    settings = utils.deepClone(self.ctx.settings) || {};\n    settings.showTooltip = utils.defaultValue(settings\n        .showTooltip, true);\n\n    Chart.defaults.global.tooltips.enabled = settings\n        .showTooltip;\n\n    var dataset = {\n        data: [],\n        backgroundColor: [],\n        borderColor: [],\n        borderWidth: [],\n        hoverBackgroundColor: []\n    }\n\n    pieData.datasets.push(dataset);\n\n    for (var i = 0; i < self.ctx.data.length; i++) {\n        var dataKey = self.ctx.data[i].dataKey;\n        //pieData.labels.push(dataKey.label + units);\n\n        alias = self.ctx.data[i].datasource.aliasName;\n        if ((alias in aliases) == false) {\n            var units = dataKey.units && dataKey.units\n                .length ? dataKey.units : self.ctx\n                .units;\n            units = units ? (' (' + units + ')') : '';\n            // set static name to aliasName (e.g. Zone1, Zone2, etc)        \n            aliases[alias] = units;\n            pieData.labels.push(alias + units);\n            dataset.data.push(0);\n        }\n        var hoverBackgroundColor = tinycolor(dataKey\n            .color).lighten(15);\n        var borderColor = tinycolor(dataKey.color)\n            .darken();\n        dataset.backgroundColor.push(dataKey.color);\n        dataset.borderColor.push('#fff');\n        dataset.borderWidth.push(5);\n        dataset.hoverBackgroundColor.push(\n            hoverBackgroundColor.toRgbString());\n    }\n\n    var floatingPoint;\n    if (typeof self.ctx.decimals !== 'undefined' && self\n        .ctx.decimals !== null) {\n        floatingPoint = self.ctx.widget.config.decimals;\n    } else {\n        floatingPoint = 2;\n    }\n\n\n    var ctx = $('#pieChart', self.ctx.$container);\n    self.ctx.chart = new Chart(ctx, {\n        type: 'polarArea',\n        data: pieData,\n        options: {\n            responsive: false,\n            maintainAspectRatio: false,\n            scale: {\n                ticks: {\n                    callback: function(tick) {\n                        return tick.toFixed(\n                            floatingPoint\n                            );\n                    }\n                }\n            }\n        }\n    });\n\n    self.onResize();\n}\n\nself.onDataUpdated = function() {\n    sums = {};\n    for (var i = 0; i < pieData.labels.length; i++) {\n        sums[pieData.labels[i]] = 0;\n    }\n    for (i = 0; i < self.ctx.data.length; i++) {\n        var cellData = self.ctx.data[i];\n        if (cellData.data.length > 0) {\n            var decimals;\n            if (typeof cellData.dataKey.decimals !==\n                'undefined' &&\n                cellData.dataKey.decimals !== null) {\n                decimals = cellData.dataKey.decimals;\n            } else {\n                decimals = self.ctx.decimals;\n            }\n            var tvPair = cellData.data[cellData.data\n                .length - 1];\n            var value = self.ctx.utils.formatValue(\n                tvPair[1], decimals);\n            alias = self.ctx.data[i].datasource.aliasName;\n            sums[alias + aliases[alias]] += parseFloat(value);\n        }\n    }\n\n    i = 0;\n    for (const [key, value] of Object.entries(sums)) {\n        self.ctx.chart.data.datasets[0].data[i] = value;\n        i++;\n    }\n\n    self.ctx.chart.update();\n}\n\nself.onResize = function() {\n    if (self.ctx.height >= 70) {\n        try {\n            self.ctx.chart.resize();\n        } catch (e) {}\n    }\n}\n\nself.onDestroy = function() {\n    self.ctx.chart.destroy();\n    self.ctx.chart = null;\n}",
        "settingsSchema": "{\n    \"schema\": {\n    \"type\": \"object\",\n    \"title\": \"EntitiesTableSettings\",\n    \"properties\": {\n        \"showTooltip\": {\n            \"title\": \"Show Tooltip\",\n            \"type\": \"boolean\",\n            \"default\": true\n        }\n    },\n    \"required\": []\n    },\n    \"form\": [\n        \"showTooltip\"\n    ]\n}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.545701115289893,\"funcBody\":\"var value = (prevValue-20) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+20;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Third\",\"color\":\"#f44336\",\"settings\":{},\"_hash\":0.2592906835158064,\"funcBody\":\"var value = (prevValue-40) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+40;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Fourth\",\"color\":\"#ffc107\",\"settings\":{},\"_hash\":0.12880275585455747,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Fifth\",\"color\":\"#607d8b\",\"settings\":{},\"_hash\":0.2074391823443591,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Sums over entities grouped by Alias\"}"
      }
    },
    {
      "alias": "time_series_aggregation_per_hour_and_sum",
      "name": "Time series aggregation - per hour & sum over series",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
      "description": "Displays aggregation (sum) of set of timeseries in buckets of hours. For example, hourly energy consumption.",
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, \"bar\");\n    self.ctx.widgetTitle = self.ctx.data[0].datasource.aliasName + \" \" + self.ctx.widgetConfig.title;\n    self.ctx.updateWidgetParams();\n}\n\nself.getBeginningOfHour = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setMinutes(0);\n    date.setSeconds(0);\n    const begHour = date.getTime();\n\n    return begHour;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getHourNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getHours();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\n\nself.popMinimalWIP = function() {\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n    \n}\n\nself.computeSums = function() {\n    let prevTimeOfTheHour = null;\n    let sums = {};\n    let hours = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Aggregate per hour. Build set of hours\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp = 0, stopHourTimestamp = 0;\n\n        for (let j = 0; j < timeseries.length; j++) {\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(timeseries[0][0] / hourUnixTs) * (hourUnixTs); // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp + hourUnixTs; // 1h later\n            }\n\n            hour = self.getHourNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n            \n            const timeOfTheHour = Math.round(\n                self.getBeginningOfHour(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheHour\n            if (prevTimeOfTheHour == null) {\n                prevTimeOfTheHour = timeOfTheHour;\n                \n            } else if (prevTimeOfTheHour == timeOfTheHour) {\n                // Avoid adding duplicates - skip taking this data point into consideration\n                continue;\n            }\n\n            if ((prevTimeOfTheHour in hours) == false) {\n                hours[prevTimeOfTheHour] = \"\";\n                sums[prevTimeOfTheHour] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][0] && timeseries[j][0] < stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints +=1;\n            } else {\n                if (j + 1 < timeseries.length) {\n                // We exceeded that time window. Move on to the next one.\n                startHourTimestamp = Math.floor(\n                    timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    3600000; // 1h later\n                }\n\n                // sum up values\n                sums[prevTimeOfTheHour] += hourlyAverage /(\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheHour] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n            \n            if (timeOfTheHour != prevTimeOfTheHour) {\n                prevTimeOfTheHour = timeOfTheHour;\n            }\n        }\n    }\n\n    // Create Array\n    let j = 0;\n    for (const [key, value] of Object.entries(hours)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }\n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Time series aggregation - per hour & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
      }
    },
    {
      "alias": "timeseries_bar_chart_aggregation_per_week2",
      "name": "Timeseries Bar Chart - aggregation per week & sum over series",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
      "description": "Displays aggregation (sum) of set of timeseries in buckets of weeks. For example, weekly energy consumption.",
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, 'bar');\n    self.ctx.widgetTitle = self.ctx.data[0].datasource.aliasName + \" \" + self.ctx.widgetConfig.title;\n    self.ctx.updateWidgetParams();\n}\n\nself.getBeginningofWeek = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n\n    const diff = date.getDate() - date.getDay() + (date\n        .getDay() === 0 ? -6 : 1);\n    const beginningWeek = new Date(date.setDate(diff));\n    const begWeek = beginningWeek.getTime();\n\n    return begWeek;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getWeekNumber = function(timestamp) {\n    var date = new Date(timestamp);\n    var oneJan = new Date(date.getFullYear(), 0, 1);\n    var numberOfDays = Math.floor((date - oneJan) / (\n        24 * 60 * 60 * 1000));\n    var weekNumber = Math.round((date.getDay() + 1 +\n        numberOfDays) / 7);\n\n    return weekNumber;\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\nself.popMinimalWIP = function() {\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n}\n\nself.computeSums = function() {\n    let sums = {};\n    let weeks = {};\n    let newTimeseries = [];\n    let prevTimeOfTheWeek = null;\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Sum aggregation per week\n    for (var i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        // Deep copy\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp, stopHourTimestamp;\n\n        for (var j = 0; j < timeseries.length; j++) {\n\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(\n                    timeseries[0][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    hourUnixTs; // 1h later\n            }\n\n            week = self.getWeekNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n\n            const timeOfTheWeek = Math.round(\n                self.getBeginningofWeek(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheWeek\n            if (prevTimeOfTheWeek == null) {\n                prevTimeOfTheWeek = timeOfTheWeek;\n            }\n\n            if ((prevTimeOfTheWeek in weeks) == false) {\n                weeks[prevTimeOfTheWeek] = \"\";\n                sums[prevTimeOfTheWeek] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][\n                    0\n                ] && timeseries[j][0] <\n                stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints++;\n            } else {\n                if (j + 1 < timeseries.length) {\n                    // We exceeded that time window. Move on to the next one.\n                    startHourTimestamp = Math.floor(\n                        timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                    stopHourTimestamp =\n                        startHourTimestamp +\n                        hourUnixTs; // 1h later\n                }\n\n                // Sum up values\n                sums[prevTimeOfTheWeek] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheWeek] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n\n            if (timeOfTheWeek != prevTimeOfTheWeek) {\n                prevTimeOfTheWeek = timeOfTheWeek;\n            }\n        }\n    }\n    \n    // Create array Array\n    j = 0;\n    for (const [key, value] of Object.entries(\n            weeks)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }    \n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":false,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":false,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000},\"aggregation\":{\"limit\":200,\"type\":\"AVG\"}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"stack\":true,\"tooltipIndividual\":false,\"defaultBarWidth\":600},\"title\":\"Timeseries Bar Chart - aggregation per week & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null,\"widgetStyle\":{},\"useDashboardTimewindow\":true,\"showLegend\":true,\"actions\":{}}"
      }
    },
    {
      "alias": "timeseries_aggregation_per_month_sum_over_series",
      "name": "Timeseries aggregation per month & sum over series",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
      "description": "Displays aggregation (sum) of set of timeseries in buckets of months. For example, monthly energy consumption.",
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, 'bar');\n    self.ctx.widgetTitle = self.ctx.data[0].datasource.aliasName + \" \" + self.ctx.widgetConfig.title;\n    self.ctx.updateWidgetParams();\n}\n\nself.getBeginningofMonth = function(timestamp) {\n    var date = new Date(timestamp);\n    var year = date.getFullYear();\n    var month = date.getMonth();\n\n    return new Date(year, month, 1).getTime();\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getMonthNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getMonth();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\nself.popMinimalWIP = function() {\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n}\n\nself.computeSums = function() {\n    let prevTimeOfTheMonth = null;\n    let sums = {};\n    let months = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Sum aggregation per month\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        // Deep copy\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp, stopHourTimestamp;\n\n        for (let j = 0; j < timeseries.length; j++) {\n\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(\n                    timeseries[0][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    hourUnixTs; // 1h later\n            }\n\n            month = self.getMonthNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n\n\n            const timeOfTheMonth = Math.round(\n                self.getBeginningofMonth(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheMonth\n            if (prevTimeOfTheMonth == null) {\n                prevTimeOfTheMonth = timeOfTheMonth;\n            }\n\n            if ((prevTimeOfTheMonth in months) == false) {\n                months[prevTimeOfTheMonth] = \"\";\n                sums[prevTimeOfTheMonth] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][\n                    0\n                ] && timeseries[j][0] <\n                stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints++;\n            } else {\n                if (j + 1 < timeseries.length) {\n                    // We exceeded that time window. Move on to the next one.\n                    startHourTimestamp = Math.floor(\n                        timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                    stopHourTimestamp =\n                        startHourTimestamp +\n                        hourUnixTs; // 1h later\n                }\n\n                // Sum up values\n                sums[prevTimeOfTheMonth] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheMonth] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n\n            if (timeOfTheMonth != prevTimeOfTheMonth) {\n                prevTimeOfTheMonth = timeOfTheMonth;\n            }\n        }\n    }\n    \n    // Create array Array\n    let j = 0;\n    for (const [key, value] of Object.entries(\n            months)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n    \n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }    \n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Timeseries aggregation per month & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
      }
    },
    {
      "alias": "timeseries_aggregation_per_day_sum_over_series",
      "name": "Timeseries aggregation per day & sum over series",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
      "description": "Displays aggregation (sum) of set of timeseries in buckets of days. For example, daily energy consumption.",
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, \"bar\");\n    self.ctx.widgetTitle = self.ctx.data[0].datasource.aliasName + \" \" + self.ctx.widgetConfig.title;\n    self.ctx.updateWidgetParams();\n}\n\nself.getBeginningOfDay = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n    const begDay = date.getTime();\n\n    return begDay;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getDayNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getDay();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\n\nself.popMinimalWIP = function() {\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n    \n}\n\nself.computeSums = function() {\n    let prevTimeOfTheDay = null;\n    let sums = {};\n    let days = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Aggregate per day. Build set of days\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp = 0, stopHourTimestamp = 0;\n\n        for (let j = 0; j < timeseries.length; j++) {\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(timeseries[0][0] / hourUnixTs) * (hourUnixTs); // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp + hourUnixTs; // 1h later\n            }\n\n            day = self.getDayNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n            \n            const timeOfTheDay = Math.round(\n                self.getBeginningOfDay(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheDay\n            if (prevTimeOfTheDay == null) {\n                prevTimeOfTheDay = timeOfTheDay;\n                \n            }\n\n            if ((prevTimeOfTheDay in days) == false) {\n                days[prevTimeOfTheDay] = \"\";\n                sums[prevTimeOfTheDay] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][0] && timeseries[j][0] < stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints +=1;\n            } else {\n                if (j + 1 < timeseries.length) {\n                // We exceeded that time window. Move on to the next one.\n                startHourTimestamp = Math.floor(\n                    timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    3600000; // 1h later\n                }\n\n                // sum up values\n                sums[prevTimeOfTheDay] += hourlyAverage /(\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheDay] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n            \n            if (timeOfTheDay != prevTimeOfTheDay) {\n                prevTimeOfTheDay = timeOfTheDay;\n            }\n        }\n    }\n\n    // Create Array\n    let j = 0;\n    for (const [key, value] of Object.entries(days)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }\n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Timeseries aggregation per day & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
      }
    }
  ]
}