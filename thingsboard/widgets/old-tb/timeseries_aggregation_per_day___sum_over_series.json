{
  "alias": "timeseries_aggregation_per_day_sum_over_series",
  "name": "Timeseries aggregation per day & sum over series",
  "image": null,
  "description": null,
  "descriptor": {
    "type": "timeseries",
    "sizeX": 8,
    "sizeY": 5,
    "resources": [],
    "templateHtml": "",
    "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
    "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, \"bar\");\n}\n\nself.getBeginningOfDay = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n    const begDay = date.getTime();\n\n    return begDay;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getDayNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getDay();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\n\nself.popMinimalWIP = function() {\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n    \n}\n\nself.computeSums = function() {\n    let prevTimeOfTheDay = null;\n    let sums = {};\n    let days = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Aggregate per day. Build set of days\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp = 0, stopHourTimestamp = 0;\n\n        for (let j = 0; j < timeseries.length; j++) {\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(timeseries[0][0] / hourUnixTs) * (hourUnixTs); // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp + hourUnixTs; // 1h later\n            }\n\n            day = self.getDayNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n            \n            const timeOfTheDay = Math.round(\n                self.getBeginningOfDay(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheDay\n            if (prevTimeOfTheDay == null) {\n                prevTimeOfTheDay = timeOfTheDay;\n                \n            }\n\n            if ((prevTimeOfTheDay in days) == false) {\n                days[prevTimeOfTheDay] = \"\";\n                sums[prevTimeOfTheDay] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][0] && timeseries[j][0] < stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints +=1;\n            } else {\n                if (j + 1 < timeseries.length) {\n                // We exceeded that time window. Move on to the next one.\n                startHourTimestamp = Math.floor(\n                    timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    3600000; // 1h later\n                }\n\n                // sum up values\n                sums[prevTimeOfTheDay] += hourlyAverage /(\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheDay] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n            \n            if (timeOfTheDay != prevTimeOfTheDay) {\n                prevTimeOfTheDay = timeOfTheDay;\n            }\n        }\n    }\n\n    // Create Array\n    let j = 0;\n    for (const [key, value] of Object.entries(days)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }\n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.getSettingsSchema = function() {\n    return TbFlot.settingsSchema('bar');\n}\n\nself.getDataKeySettingsSchema = function() {\n    return TbFlot.datakeySettingsSchema(false, 'bar');\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
    "settingsSchema": "{}",
    "dataKeySettingsSchema": "{}",
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Timeseries aggregation per day & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
  }
}
