{
  "widgetsBundle": {
    "alias": "test2",
    "title": "Custom made",
    "image": null,
    "description": null
  },
  "widgetTypes": [
    {
      "alias": "test2",
      "name": "Sum all",
      "image": null,
      "description": null,
      "descriptor": {
        "type": "latest",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "",
        "templateCss": "#container {\n    overflow: auto;\n}\n\n.tbDatasource-container {\n    margin: 5px;\n    padding: 8px;\n}\n\n.tbDatasource-title {\n    font-size: 1.200rem;\n    font-weight: 500;\n    padding-bottom: 10px;\n}\n\n.tbDatasource-table {\n    width: 100%;\n    box-shadow: 0 0 10px #ccc;\n    border-collapse: collapse;\n    white-space: nowrap;\n    font-size: 1.000rem;\n    color: #757575;\n}\n\n.tbDatasource-table td {\n    position: relative;\n    border-top: 1px solid rgba(0, 0, 0, 0.12);\n    border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n    padding: 0px 18px;\n    box-sizing: border-box;\n}",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\nself.onInit = function() {\n    \n    self.ctx.datasourceTitleCells = [];\n    self.ctx.valueCells = [];\n    self.ctx.labelCells = [];\n\n    // Create table with 1 entry\n    self.ctx.$container.append(\n    \"<div id='singleentry' class='tbDatasource-container'></div>\"\n    );\n    var datasourceContainer = $('#singleentry',\n    self.ctx.$container);\n\n    datasourceContainer.append(\n        \"<div class='tbDatasource-title'>Sum</div>\"\n    );\n\n    var datasourceTitleCell = $('.tbDatasource-title', datasourceContainer);\n    self.ctx.datasourceTitleCells.push(datasourceTitleCell);\n    \n    datasourceContainer.append(\n        \"<table id='table0' class='tbDatasource-table'><col width='30%'><col width='70%'></table>\"\n    );\n\n    // Each datasource is a device, for example\n    for (var i=0; i < self.ctx.datasources.length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n        \n        var tableId = 'table' + i;\n        var table = $('#' + tableId, self.ctx.$container);\n\n        // Gets value of key for the first device - why??\n        for (var a = 0; a < tbDatasource.dataKeys.length; a++) {\n            var dataKey = tbDatasource.dataKeys[a];\n            var labelCellId = 'labelCell' + a;\n            var cellId = 'cell' + a;\n            table.append(\"<tr><td id='\" + labelCellId + \"'>\" + dataKey.label +\n                \"</td><td id='\" + cellId +\n                \"'></td></tr>\");\n            var labelCell = $('#' + labelCellId, table);\n            self.ctx.labelCells.push(labelCell);\n            var valueCell = $('#' + cellId, table);\n            self.ctx.valueCells.push(valueCell);\n        }\n        \n    }    \n    \n    self.onResize();\n}\n\n// Compute sum over datasources (e.g. entities such as device1, device2, device3)\nself.onDataUpdated = function() {\n    var sum = 0;\n    // For each entity (device1, device2, etc)\n    for (var i=0; i < self.ctx.datasources.length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n        for (var a = 0; a < tbDatasource.dataKeys.length; a++) {\n            // Read all values\n            var cellData = self.ctx.data[i];\n            if (cellData && cellData.data && cellData.data.length > 0) {\n                var tvPair = cellData.data[cellData.data.length -\n                    1];\n                var value = tvPair[1];\n                var textValue;\n                //toDo -> + IsNumber\n                \n                if (isNumber(value)) {\n                    var decimals = self.ctx.decimals;\n                    var units = self.ctx.units;\n                    if (cellData.dataKey.decimals || cellData.dataKey.decimals === 0) {\n                        decimals = cellData.dataKey.decimals;\n                    }\n                    if (cellData.dataKey.units) {\n                        units = cellData.dataKey.units;\n                    }\n                    txtValue = self.ctx.utils.formatValue(value, decimals, units, true);\n                    sum = sum + parseFloat(value);\n                } else {\n                    txtValue = value;\n                }\n            }\n        }\n    }\n    \n    //self.ctx.valueCells[0].html(sum);\n    measurement = sum.toFixed(2) + \" \" + self.ctx.units; // Keep only 2 digits after decimal\n    self.ctx.valueCells[0].html(measurement);\n    \n    function isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n}\n\nself.onResize = function() {\n    var datasourceTitleFontSize = self.ctx.height/8;\n    if (self.ctx.width/self.ctx.height <= 1.5) {\n        datasourceTitleFontSize = self.ctx.width/12;\n    }\n    datasourceTitleFontSize = Math.min(datasourceTitleFontSize, 20);\n    for (var i = 0; i < self.ctx.datasourceTitleCells.length; i++) {\n        self.ctx.datasourceTitleCells[i].css('font-size', datasourceTitleFontSize+'px');\n    }\n    var valueFontSize = self.ctx.height/9;\n    var labelFontSize = self.ctx.height/9;\n    if (self.ctx.width/self.ctx.height <= 1.5) {\n        valueFontSize = self.ctx.width/15;\n        labelFontSize = self.ctx.width/15;\n    }\n    valueFontSize = Math.min(valueFontSize, 18);\n    labelFontSize = Math.min(labelFontSize, 18);\n\n    for (i = 0; i < self.ctx.valueCells; i++) {\n        self.ctx.valueCells[i].css('font-size', valueFontSize+'px');\n        self.ctx.valueCells[i].css('height', valueFontSize*2.5+'px');\n        self.ctx.valueCells[i].css('padding', '0px ' + valueFontSize + 'px');\n        self.ctx.labelCells[i].css('font-size', labelFontSize+'px');\n        self.ctx.labelCells[i].css('height', labelFontSize*2.5+'px');\n        self.ctx.labelCells[i].css('padding', '0px ' + labelFontSize + 'px');\n    }    \n}\n\nself.onDestroy = function() {\n}\n",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Sum all\"}"
      }
    },
    {
      "alias": "average",
      "name": "Average",
      "image": null,
      "description": null,
      "descriptor": {
        "type": "latest",
        "sizeX": 7.5,
        "sizeY": 3,
        "resources": [],
        "templateHtml": "",
        "templateCss": "#container {\n    overflow: auto;\n}\n\n.tbDatasource-container {\n    margin: 5px;\n    padding: 8px;\n}\n\n.tbDatasource-title {\n    font-size: 1.200rem;\n    font-weight: 500;\n    padding-bottom: 10px;\n}\n\n.tbDatasource-table {\n    width: 100%;\n    box-shadow: 0 0 10px #ccc;\n    border-collapse: collapse;\n    white-space: nowrap;\n    font-size: 1.000rem;\n    color: #757575;\n}\n\n.tbDatasource-table td {\n    position: relative;\n    border-top: 1px solid rgba(0, 0, 0, 0.12);\n    border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n    padding: 0px 18px;\n    box-sizing: border-box;\n}",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\nself.onInit = function() {\n\n    self.ctx.datasourceTitleCells = [];\n    self.ctx.valueCells = [];\n    self.ctx.labelCells = [];\n\n    // Create table with 1 entry\n    self.ctx.$container.append(\n        \"<div id='singleentry' class='tbDatasource-container'></div>\"\n    );\n    var datasourceContainer = $('#singleentry',\n        self.ctx.$container);\n\n    datasourceContainer.append(\n        \"<div class='tbDatasource-title'>Average</div>\"\n    );\n\n    var datasourceTitleCell = $('.tbDatasource-title',\n        datasourceContainer);\n    self.ctx.datasourceTitleCells.push(\n        datasourceTitleCell);\n\n    datasourceContainer.append(\n        \"<table id='table0' class='tbDatasource-table'><col width='30%'><col width='70%'></table>\"\n    );\n\n    // Each datasource is a device, for example\n    for (var i = 0; i < self.ctx.datasources\n        .length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n\n        var tableId = 'table' + i;\n        var table = $('#' + tableId, self.ctx\n            .$container);\n\n        // Gets value of key for the first device - why??\n        for (var a = 0; a < tbDatasource.dataKeys\n            .length; a++) {\n            var dataKey = tbDatasource.dataKeys[a];\n            var labelCellId = 'labelCell' + a;\n            var cellId = 'cell' + a;\n            table.append(\"<tr><td id='\" + labelCellId +\n                \"'>\" + dataKey.label +\n                \"</td><td id='\" + cellId +\n                \"'></td></tr>\");\n            var labelCell = $('#' + labelCellId, table);\n            self.ctx.labelCells.push(labelCell);\n            var valueCell = $('#' + cellId, table);\n            self.ctx.valueCells.push(valueCell);\n        }\n\n    }\n\n    self.onResize();\n}\n\n// Compute sum over datasources (e.g. entities such as device1, device2, device3)\nself.onDataUpdated = function() {\n    var sum = 0;\n    // For each entity (device1, device2, etc)\n    for (var i = 0; i < self.ctx.datasources\n        .length; i++) {\n        var tbDatasource = self.ctx.datasources[i];\n        for (var a = 0; a < tbDatasource.dataKeys\n            .length; a++) {\n            // Read all values\n            var cellData = self.ctx.data[i];\n            if (cellData && cellData.data && cellData\n                .data.length > 0) {\n                var tvPair = cellData.data[cellData.data\n                    .length -\n                    1];\n                var value = tvPair[1];\n                var textValue;\n                //toDo -> + IsNumber\n\n                if (isNumber(value)) {\n                    var decimals = self.ctx.decimals;\n                    var units = self.ctx.units;\n                    if (cellData.dataKey.decimals ||\n                        cellData.dataKey.decimals === 0\n                        ) {\n                        decimals = cellData.dataKey\n                            .decimals;\n                    }\n                    if (cellData.dataKey.units) {\n                        units = cellData.dataKey.units;\n                    }\n                    txtValue = self.ctx.utils\n                        .formatValue(value, decimals,\n                            units, true);\n                    sum = sum + parseFloat(value, 2);\n                } else {\n                    txtValue = value;\n                }\n            }\n        }\n    }\n\n    if (self.ctx.datasources.length > 0) {\n        avg = sum / self.ctx.datasources.length;\n    }\n    //self.ctx.valueCells[0].html(avg.toFixed(2));\n    measurement = avg.toFixed(2) + \" \" + self.ctx.units;\n    self.ctx.valueCells[0].html(measurement);\n\n    function isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n}\n\nself.onResize = function() {\n    var datasourceTitleFontSize = self.ctx.height / 8;\n    if (self.ctx.width / self.ctx.height <= 1.5) {\n        datasourceTitleFontSize = self.ctx.width / 12;\n    }\n    datasourceTitleFontSize = Math.min(\n        datasourceTitleFontSize, 20);\n    for (var i = 0; i < self.ctx.datasourceTitleCells\n        .length; i++) {\n        self.ctx.datasourceTitleCells[i].css(\n            'font-size', datasourceTitleFontSize +\n            'px');\n    }\n    var valueFontSize = self.ctx.height / 9;\n    var labelFontSize = self.ctx.height / 9;\n    if (self.ctx.width / self.ctx.height <= 1.5) {\n        valueFontSize = self.ctx.width / 15;\n        labelFontSize = self.ctx.width / 15;\n    }\n    valueFontSize = Math.min(valueFontSize, 18);\n    labelFontSize = Math.min(labelFontSize, 18);\n\n    for (i = 0; i < self.ctx.valueCells; i++) {\n        self.ctx.valueCells[i].css('font-size',\n            valueFontSize + 'px');\n        self.ctx.valueCells[i].css('height',\n            valueFontSize * 2.5 + 'px');\n        self.ctx.valueCells[i].css('padding', '0px ' +\n            valueFontSize + 'px');\n        self.ctx.labelCells[i].css('font-size',\n            labelFontSize + 'px');\n        self.ctx.labelCells[i].css('height',\n            labelFontSize * 2.5 + 'px');\n        self.ctx.labelCells[i].css('padding', '0px ' +\n            labelFontSize + 'px');\n    }\n}\n\nself.onDestroy = function() {}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Random\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Average\"}"
      }
    },
    {
      "alias": "polar_area_chart_js",
      "name": "Sums over entities grouped by Alias",
      "image": "data:image/png;base64,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",
      "description": "Displays sum of latest values of the attributes or timeseries data for multiple entities in a polar area chart. Supports numeric values only.",
      "descriptor": {
        "type": "latest",
        "sizeX": 7,
        "sizeY": 5,
        "resources": [
          {
            "url": "https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.3.0/Chart.min.js"
          }
        ],
        "templateHtml": "<canvas id=\"pieChart\"></canvas>\n",
        "templateCss": "",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\nvar pieData = {\n    labels: [],\n    datasets: []\n};\n\nvar aliases = {};\n\nself.onInit = function() {\n    $scope = self.ctx.$scope;\n    utils = $scope.$injector.get(self.ctx.servicesMap\n        .get('utils'));\n    settings = utils.deepClone(self.ctx.settings) || {};\n    settings.showTooltip = utils.defaultValue(settings\n        .showTooltip, true);\n\n    Chart.defaults.global.tooltips.enabled = settings\n        .showTooltip;\n\n    var dataset = {\n        data: [],\n        backgroundColor: [],\n        borderColor: [],\n        borderWidth: [],\n        hoverBackgroundColor: []\n    }\n\n    pieData.datasets.push(dataset);\n\n    for (var i = 0; i < self.ctx.data.length; i++) {\n        var dataKey = self.ctx.data[i].dataKey;\n        //pieData.labels.push(dataKey.label + units);\n\n        alias = self.ctx.data[i].datasource.aliasName;\n        if ((alias in aliases) == false) {\n            var units = dataKey.units && dataKey.units\n                .length ? dataKey.units : self.ctx\n                .units;\n            units = units ? (' (' + units + ')') : '';\n            // set static name to aliasName (e.g. Zone1, Zone2, etc)        \n            aliases[alias] = units;\n            pieData.labels.push(alias + units);\n            dataset.data.push(0);\n        }\n        var hoverBackgroundColor = tinycolor(dataKey\n            .color).lighten(15);\n        var borderColor = tinycolor(dataKey.color)\n            .darken();\n        dataset.backgroundColor.push(dataKey.color);\n        dataset.borderColor.push('#fff');\n        dataset.borderWidth.push(5);\n        dataset.hoverBackgroundColor.push(\n            hoverBackgroundColor.toRgbString());\n    }\n\n    var floatingPoint;\n    if (typeof self.ctx.decimals !== 'undefined' && self\n        .ctx.decimals !== null) {\n        floatingPoint = self.ctx.widget.config.decimals;\n    } else {\n        floatingPoint = 2;\n    }\n\n\n    var ctx = $('#pieChart', self.ctx.$container);\n    self.ctx.chart = new Chart(ctx, {\n        type: 'polarArea',\n        data: pieData,\n        options: {\n            responsive: false,\n            maintainAspectRatio: false,\n            scale: {\n                ticks: {\n                    callback: function(tick) {\n                        return tick.toFixed(\n                            floatingPoint\n                            );\n                    }\n                }\n            }\n        }\n    });\n\n    self.onResize();\n}\n\nself.onDataUpdated = function() {\n    sums = {};\n    for (var i = 0; i < pieData.labels.length; i++) {\n        sums[pieData.labels[i]] = 0;\n    }\n    for (i = 0; i < self.ctx.data.length; i++) {\n        var cellData = self.ctx.data[i];\n        if (cellData.data.length > 0) {\n            var decimals;\n            if (typeof cellData.dataKey.decimals !==\n                'undefined' &&\n                cellData.dataKey.decimals !== null) {\n                decimals = cellData.dataKey.decimals;\n            } else {\n                decimals = self.ctx.decimals;\n            }\n            var tvPair = cellData.data[cellData.data\n                .length - 1];\n            var value = self.ctx.utils.formatValue(\n                tvPair[1], decimals);\n            alias = self.ctx.data[i].datasource.aliasName;\n            sums[alias + aliases[alias]] += parseFloat(value);\n        }\n    }\n\n    i = 0;\n    for (const [key, value] of Object.entries(sums)) {\n        self.ctx.chart.data.datasets[0].data[i] = value;\n        i++;\n    }\n\n    self.ctx.chart.update();\n}\n\nself.onResize = function() {\n    if (self.ctx.height >= 70) {\n        try {\n            self.ctx.chart.resize();\n        } catch (e) {}\n    }\n}\n\nself.onDestroy = function() {\n    self.ctx.chart.destroy();\n    self.ctx.chart = null;\n}",
        "settingsSchema": "{\n    \"schema\": {\n    \"type\": \"object\",\n    \"title\": \"EntitiesTableSettings\",\n    \"properties\": {\n        \"showTooltip\": {\n            \"title\": \"Show Tooltip\",\n            \"type\": \"boolean\",\n            \"default\": true\n        }\n    },\n    \"required\": []\n    },\n    \"form\": [\n        \"showTooltip\"\n    ]\n}",
        "dataKeySettingsSchema": "{}\n",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{},\"_hash\":0.15479322438769105,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#4caf50\",\"settings\":{},\"_hash\":0.545701115289893,\"funcBody\":\"var value = (prevValue-20) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+20;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Third\",\"color\":\"#f44336\",\"settings\":{},\"_hash\":0.2592906835158064,\"funcBody\":\"var value = (prevValue-40) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+40;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Fourth\",\"color\":\"#ffc107\",\"settings\":{},\"_hash\":0.12880275585455747,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Fifth\",\"color\":\"#607d8b\",\"settings\":{},\"_hash\":0.2074391823443591,\"funcBody\":\"var value = (prevValue-50) + Math.random() * 2 - 1;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 100) {\\n\\tvalue = 100;\\n}\\nreturn value+50;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{},\"title\":\"Sums over entities grouped by Alias\"}"
      }
    },
    {
      "alias": "timeseries_bar_chart_aggregation_per_week2",
      "name": "Timeseries Bar Chart - aggregation per week & sum over series",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
      "description": "Displays changes to timeseries data over time. For example, daily water consumption for last month.",
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, 'bar');\n}\n\nself.getBeginningofWeek = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n\n    const diff = date.getDate() - date.getDay() + (date\n        .getDay() === 0 ? -6 : 1);\n    const beginningWeek = new Date(date.setDate(diff));\n    const begWeek = beginningWeek.getTime();\n\n    return begWeek;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getWeekNumber = function(timestamp) {\n    var date = new Date(timestamp);\n    var oneJan = new Date(date.getFullYear(), 0, 1);\n    var numberOfDays = Math.floor((date - oneJan) / (\n        24 * 60 * 60 * 1000));\n    var weekNumber = Math.round((date.getDay() + 1 +\n        numberOfDays) / 7);\n\n    return weekNumber;\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\nself.popMinimalWIP = function() {\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n}\n\nself.computeSums = function() {\n    let sums = {};\n    let weeks = {};\n    let newTimeseries = [];\n    let prevTimeOfTheWeek = null;\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Sum aggregation per week\n    for (var i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        // Deep copy\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp, stopHourTimestamp;\n\n        for (var j = 0; j < timeseries.length; j++) {\n\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(\n                    timeseries[0][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    hourUnixTs; // 1h later\n            }\n\n            week = self.getWeekNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n\n            const timeOfTheWeek = Math.round(\n                self.getBeginningofWeek(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n            /*\n            const timeOfTheWeek = (Math.round(\n                self.getBeginningofWeek(timeseries[j]\n                    [0]) / 1000)) * 1000;\n            */\n\n            // Update first time prevTimeOfTheWeek\n            if (prevTimeOfTheWeek == null) {\n                prevTimeOfTheWeek = timeOfTheWeek;\n            }\n\n            if ((prevTimeOfTheWeek in weeks) == false) {\n                weeks[prevTimeOfTheWeek] = \"\";\n                sums[prevTimeOfTheWeek] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][\n                    0\n                ] && timeseries[j][0] <\n                stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints++;\n            } else {\n                if (j + 1 < timeseries.length) {\n                    // We exceeded that time window. Move on to the next one.\n                    startHourTimestamp = Math.floor(\n                        timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                    stopHourTimestamp =\n                        startHourTimestamp +\n                        hourUnixTs; // 1h later\n                }\n\n                // Sum up values\n                sums[prevTimeOfTheWeek] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheWeek] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n\n            if (timeOfTheWeek != prevTimeOfTheWeek) {\n                prevTimeOfTheWeek = timeOfTheWeek;\n            }\n        }\n    }\n    \n    // Create array Array\n    j = 0;\n    for (const [key, value] of Object.entries(\n            weeks)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }    \n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.getSettingsSchema = function() {\n    return TbFlot.settingsSchema('bar');\n}\n\nself.getDataKeySettingsSchema = function() {\n    return TbFlot.datakeySettingsSchema(false, 'bar');\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":false,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":false,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000},\"aggregation\":{\"limit\":200,\"type\":\"AVG\"}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"stack\":true,\"tooltipIndividual\":false,\"defaultBarWidth\":600},\"title\":\"Timeseries Bar Chart - aggregation per week & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null,\"widgetStyle\":{},\"useDashboardTimewindow\":true,\"showLegend\":true,\"actions\":{}}"
      }
    },
    {
      "alias": "timeseries_aggregation_per_day_sum_over_series",
      "name": "Timeseries aggregation per day & sum over series",
      "image": null,
      "description": null,
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, \"bar\");\n}\n\nself.getBeginningOfDay = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n    const begDay = date.getTime();\n\n    return begDay;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getDayNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getDay();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\n\nself.popMinimalWIP = function() {\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n    \n}\n\nself.computeSums = function() {\n    let prevTimeOfTheDay = null;\n    let sums = {};\n    let days = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Aggregate per day. Build set of days\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp = 0, stopHourTimestamp = 0;\n\n        for (let j = 0; j < timeseries.length; j++) {\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(timeseries[0][0] / hourUnixTs) * (hourUnixTs); // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp + hourUnixTs; // 1h later\n            }\n\n            day = self.getDayNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n            \n            const timeOfTheDay = Math.round(\n                self.getBeginningOfDay(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n\n            // Update first time prevTimeOfTheDay\n            if (prevTimeOfTheDay == null) {\n                prevTimeOfTheDay = timeOfTheDay;\n                \n            }\n\n            if ((prevTimeOfTheDay in days) == false) {\n                days[prevTimeOfTheDay] = \"\";\n                sums[prevTimeOfTheDay] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][0] && timeseries[j][0] < stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints +=1;\n            } else {\n                if (j + 1 < timeseries.length) {\n                // We exceeded that time window. Move on to the next one.\n                startHourTimestamp = Math.floor(\n                    timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    3600000; // 1h later\n                }\n\n                // sum up values\n                sums[prevTimeOfTheDay] += hourlyAverage /(\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheDay] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n            \n            if (timeOfTheDay != prevTimeOfTheDay) {\n                prevTimeOfTheDay = timeOfTheDay;\n            }\n        }\n    }\n\n    // Create Array\n    let j = 0;\n    for (const [key, value] of Object.entries(days)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }\n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.getSettingsSchema = function() {\n    return TbFlot.settingsSchema('bar');\n}\n\nself.getDataKeySettingsSchema = function() {\n    return TbFlot.datakeySettingsSchema(false, 'bar');\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Timeseries aggregation per day & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
      }
    },
    {
      "alias": "timeseries_aggregation_per_month_sum_over_series",
      "name": "Timeseries aggregation per month & sum over series",
      "image": null,
      "description": null,
      "descriptor": {
        "type": "timeseries",
        "sizeX": 8,
        "sizeY": 5,
        "resources": [],
        "templateHtml": "",
        "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
        "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, 'bar');\n}\n\nself.getBeginningofMonth = function(timestamp) {\n    var date = new Date(timestamp);\n    var year = date.getFullYear();\n    var month = date.getMonth();\n\n    return new Date(year, month, 1).getTime();\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getMonthNumber = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getMonth();\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\nself.popMinimalWIP = function() {\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n}\n\nself.computeSums = function() {\n    let prevTimeOfTheMonth = null;\n    let sums = {};\n    let months = {};\n    let newTimeseries = [];\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Sum aggregation per month\n    for (let i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        // Deep copy\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp, stopHourTimestamp;\n\n        for (let j = 0; j < timeseries.length; j++) {\n\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(\n                    timeseries[0][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    hourUnixTs; // 1h later\n            }\n\n            month = self.getMonthNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n\n\n            const timeOfTheMonth = Math.round(\n                self.getBeginningofMonth(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n            /*\n            const timeOfTheMonth = (Math.round(\n                self.getBeginningofMonth(timeseries[j]\n                    [0]) / 1000)) * 1000;\n            */\n\n            // Update first time prevTimeOfTheMonth\n            if (prevTimeOfTheMonth == null) {\n                prevTimeOfTheMonth = timeOfTheMonth;\n            }\n\n            if ((prevTimeOfTheMonth in months) == false) {\n                months[prevTimeOfTheMonth] = \"\";\n                sums[prevTimeOfTheMonth] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][\n                    0\n                ] && timeseries[j][0] <\n                stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints++;\n            } else {\n                if (j + 1 < timeseries.length) {\n                    // We exceeded that time window. Move on to the next one.\n                    startHourTimestamp = Math.floor(\n                        timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                    stopHourTimestamp =\n                        startHourTimestamp +\n                        hourUnixTs; // 1h later\n                }\n\n                // Sum up values\n                sums[prevTimeOfTheMonth] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheMonth] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n\n            if (timeOfTheMonth != prevTimeOfTheMonth) {\n                prevTimeOfTheMonth = timeOfTheMonth;\n            }\n        }\n    }\n    \n    // Create array Array\n    let j = 0;\n    for (const [key, value] of Object.entries(\n            months)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n    \n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }    \n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.getSettingsSchema = function() {\n    return TbFlot.settingsSchema('bar');\n}\n\nself.getDataKeySettingsSchema = function() {\n    return TbFlot.datakeySettingsSchema(false, 'bar');\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
        "settingsSchema": "{}",
        "dataKeySettingsSchema": "{}",
        "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"Timeseries aggregation per month & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
      }
    }
  ]
}
