{
  "alias": "timeseries_bar_chart_aggregation_per_week2",
  "name": "Timeseries Bar Chart - aggregation per week & sum over series",
  "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAACgCAMAAAB+IdObAAABOFBMVEUAAAA3oPR3d3d6enp8fHyBgYGDg4OGhoaNjY2RkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqcnJydnZ2enp6goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKytra2urq6wsLCxsbGysrK0tLS1tbW2tra3t7e4uLi5ubm6urq8vLy9vb2+vr6/v7/AwMDBwcHDw8PExMTHx8fIyMjJycnLy8vNzc3Ozs7Pz8/S0tLT09PU1NTV1dXW1tbX19fZ2dna2trb29vc3Nzd3d3e3t7f39/h4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fH09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7/xx////8KXFhiAAAAAWJLR0RnW9PpswAAAvtJREFUeNrt3GtXElEUBuDpZlAqylVHCyMwyi4SpkaWAl4qk8wwUhJlmOn9//+gLzbKbc6AAm5991p82WvPOedZZw6zYM3aGupCQ4tYkZDSsKDrocNVvz8jHQKYY1ZiT/6OAJllRPSpsnzIqIG9SjYmHpKfAzI4CIuHjJeBtyHfZwCatiI1/m+BYV2Dw35NniOEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQUp/6Wx+DgbRbxOAhEb/fXJ98akiH1AIAHtSWlqRDSvdDGcOHnYR0SPV7zVsaQyHeO0jTJapEV5C9bUz9fIjsvHRIefhRxHqpjxzA3ftajXOudHGJOtHV+1rV04/wHenDc2QQkFbLJISQwUDaP90IIYQQQgghpAvIxRO9gFxG4lZ9XBFIx6sihJD+QVRjEEIIIYQQcoMgahkhhBDSe0iLX3ydQdSLIKR9ghCJkIYEIYQQIhPS8d+AhPQboppFw9HMxBrs/lqCIbObpgezP67YjnQ8iwagHDzrryUZUgsUz/prCYZY05vn+msJhiwM6XrR7q/V9OJU4xQuEpcxRsezNPbXEn3Yzz9Hulg3IYT0C3LxxI2CNCQIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQlpA7P5a0iF2fy3hkLP+WsIhVbu/lvRby+6vJR1i99eSG6ffu1XHxlRNcfWq3I0iIK4tJK2nXVyV0lOqEmvjGWAtvnCu+jMzkQWMiOlYdRSd3MAH/UnVPWR/ApFfSkcpiOBvRc3XtAeYW1ZUJbZMD5C8azhWLX4xvZVR692Se0huHm9ySogxkhs3lFVewPM4WlFUlUMoJEYUox1+jAFIbLuHrKaQWlMu8TicDp+4gdw7/qS4t2qBohk4UUF2nieBfLyDM/ItgXhBucT113i14QbixW7M+SRNb6EQ0u8kHavyZQxj2/kgNUCsYDRoqXfEF/Mdu4G8D43uOtakh3R9H1DsyKZvOmneDjt+D/0DTzolrPMHmggAAAAASUVORK5CYII=",
  "description": "Displays changes to timeseries data over time. For example, daily water consumption for last month.",
  "descriptor": {
    "type": "timeseries",
    "sizeX": 8,
    "sizeY": 5,
    "resources": [],
    "templateHtml": "",
    "templateCss": ".legend {\n    font-size: 13px;\n    line-height: 10px;\n}\n\n.legend table { \n    border-spacing: 0px;\n    border-collapse: separate;\n}\n\n.mouse-events .flot-overlay {\n    cursor: crosshair; \n}\n\n",
    "controllerScript": "/**\n * @license\n * Copyright (c) 2023 Cisco and/or its affiliates.\n *\n * This software is licensed to you under the terms of the Cisco Sample\n * Code License, Version 1.1 (the \"License\"). You may obtain a copy of the\n * License at\n *\n *                https://developer.cisco.com/docs/licenses\n *\n * All use of the material herein must be in accordance with the terms of\n * the License. All rights not expressly granted by the License are\n * reserved. Unless required by applicable law or agreed to separately in\n * writing, software distributed under the License is distributed on an \"AS\n * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied.\n */\n// If used with Non-aggregated data, make sure to set a big value for bar width\n//  and to ask for historical data rather than realtime data.\n\nself.onInit = function() {\n    self.ctx.flot = new TbFlot(self.ctx, 'bar');\n}\n\nself.getBeginningofWeek = function(timestamp) {\n    var date = new Date(timestamp);\n    date.setHours(0);\n    date.setMinutes(0);\n    date.setSeconds(0);\n\n    const diff = date.getDate() - date.getDay() + (date\n        .getDay() === 0 ? -6 : 1);\n    const beginningWeek = new Date(date.setDate(diff));\n    const begWeek = beginningWeek.getTime();\n\n    return begWeek;\n}\n\nself.getYear = function(timestamp) {\n    var date = new Date(timestamp);\n\n    return date.getFullYear();\n}\n\nself.getWeekNumber = function(timestamp) {\n    var date = new Date(timestamp);\n    var oneJan = new Date(date.getFullYear(), 0, 1);\n    var numberOfDays = Math.floor((date - oneJan) / (\n        24 * 60 * 60 * 1000));\n    var weekNumber = Math.round((date.getDay() + 1 +\n        numberOfDays) / 7);\n\n    return weekNumber;\n}\n\nself.overwriteWithAliasName = function() {\n    // Overwrite the name, label, and pattern (for the legend)\n    var origKeyName = self.ctx.flot.ctx.data[0].dataKey.name;\n    self.ctx.flot.ctx.data[0].dataKey.name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.label = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.data[0].dataKey.pattern = self.ctx\n        .data[0].datasource.aliasName;\n\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].name = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].pattern = self.ctx\n        .data[0].datasource.aliasName;\n    self.ctx.flot.ctx.flot.subscription.legendData.keys[\n            0].label = self.ctx\n        .data[0].datasource.aliasName;\n}\n\nself.popMinimalWIP = function() {\n    for (i = 1; i < self.ctx.data\n        .length; i++) {\n        // Remove original series except for first one\n        self.ctx.data[i].data.splice(0, self.ctx.data[i]\n            .data.length);\n        self.ctx.data[i].datasource = {};\n        self.ctx.data[i].dataKey = {};\n        self.ctx.datasources[i] = {};\n    }\n\n    while (self.ctx.data.length > 1) {\n        self.ctx.data.pop();\n    }\n\n    // Remark: the legend modifications throw an error\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.data.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .data.pop();\n    }\n    while (self.ctx.flot.ctx.flot.subscription\n        .legendData.keys.length > 1) {\n        self.ctx.flot.ctx.flot.subscription.legendData\n            .keys.pop();\n    }\n}\n\nself.computeSums = function() {\n    let sums = {};\n    let weeks = {};\n    let newTimeseries = [];\n    let prevTimeOfTheWeek = null;\n    let hourUnixTs = 1000 * 60 * 60;\n\n    // Sum aggregation per week\n    for (var i = 0; i < self.ctx.data\n        .length; i++) { // Traverse datasources\n        // Deep copy\n        let timeseries = [...self.ctx.data[i].data];\n\n        // Takes timeseries of a device, computes an hourly average and when hour is\n        // exceeded, adds this average to the total sum.\n        let hourlyAverage = 0;\n        let nrDatapoints = 0;\n        let startHourTimestamp, stopHourTimestamp;\n\n        for (var j = 0; j < timeseries.length; j++) {\n\n            // Initialization\n            if (j == 0) {\n                // Define hour interval\n                startHourTimestamp = Math.floor(\n                    timeseries[0][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                stopHourTimestamp = startHourTimestamp +\n                    hourUnixTs; // 1h later\n            }\n\n            week = self.getWeekNumber(timeseries[j][0]);\n            year = self.getYear(timeseries[j][0]);\n\n            const timeOfTheWeek = Math.round(\n                self.getBeginningofWeek(Math.floor(timeseries[j]\n                    [0] / 1000) * 1000));\n            /*\n            const timeOfTheWeek = (Math.round(\n                self.getBeginningofWeek(timeseries[j]\n                    [0]) / 1000)) * 1000;\n            */\n\n            // Update first time prevTimeOfTheWeek\n            if (prevTimeOfTheWeek == null) {\n                prevTimeOfTheWeek = timeOfTheWeek;\n            }\n\n            if ((prevTimeOfTheWeek in weeks) == false) {\n                weeks[prevTimeOfTheWeek] = \"\";\n                sums[prevTimeOfTheWeek] = 0;\n            }\n\n            if (startHourTimestamp <= timeseries[j][\n                    0\n                ] && timeseries[j][0] <\n                stopHourTimestamp) {\n                // Add to hourlyAverage\n                hourlyAverage += timeseries[j][1];\n                nrDatapoints++;\n            } else {\n                if (j + 1 < timeseries.length) {\n                    // We exceeded that time window. Move on to the next one.\n                    startHourTimestamp = Math.floor(\n                        timeseries[j][0] / hourUnixTs) * hourUnixTs; // timestamp of beginning of hour\n                    stopHourTimestamp =\n                        startHourTimestamp +\n                        hourUnixTs; // 1h later\n                }\n\n                // Sum up values\n                sums[prevTimeOfTheWeek] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n\n                hourlyAverage = timeseries[j][1];\n                nrDatapoints = 1;\n            }\n            \n            if (j+1 == timeseries.length) {\n                // Add last hourly average before ending the traversal\n                sums[prevTimeOfTheWeek] += hourlyAverage / (\n                    nrDatapoints ? nrDatapoints : 1);\n            }\n\n            if (timeOfTheWeek != prevTimeOfTheWeek) {\n                prevTimeOfTheWeek = timeOfTheWeek;\n            }\n        }\n    }\n    \n    // Create array Array\n    j = 0;\n    for (const [key, value] of Object.entries(\n            weeks)) {\n        newTimeseries[j] = [Number(key), sums[key]];\n        j++;\n    }\n\n    // Sort based on timestamp, otherwise, the plot does not read properly\n    newTimeseries.sort();\n    return newTimeseries;\n}\n\nself.onDataUpdated = function() {\n    if (self.ctx.data.length > 0 && self.ctx.data[0].data.length > 0) {\n        var newTimeseries = self.computeSums();\n\n        self.ctx.data[0].data = newTimeseries;\n        \n        self.overwriteWithAliasName();\n        \n        self.popMinimalWIP();\n    }    \n\n    self.ctx.flot.update();\n}\n\nself.onResize = function() {\n    self.ctx.flot.resize();\n}\n\nself.onEditModeChanged = function() {\n    self.ctx.flot.checkMouseEvents();\n}\n\nself.getSettingsSchema = function() {\n    return TbFlot.settingsSchema('bar');\n}\n\nself.getDataKeySettingsSchema = function() {\n    return TbFlot.datakeySettingsSchema(false, 'bar');\n}\n\nself.onDestroy = function() {\n    self.ctx.flot.destroy();\n}",
    "settingsSchema": "{}",
    "dataKeySettingsSchema": "{}",
    "defaultConfig": "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":false,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":false,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < 0) {\\n\\tvalue = 0;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000},\"aggregation\":{\"limit\":200,\"type\":\"AVG\"}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"stack\":true,\"tooltipIndividual\":false,\"defaultBarWidth\":600},\"title\":\"Timeseries Bar Chart - aggregation per week & sum over series\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null,\"widgetStyle\":{},\"useDashboardTimewindow\":true,\"showLegend\":true,\"actions\":{}}"
  }
}
